%% joser_template.tex
%% V1
%% 2008/12/15
%% by Davide Brugali
%% This is a skeleton file demonstrating the use of joser1.cls
%% with a JOSER paper
%%
%% This file is a modified version of bare_jrnl_compsoc.tex V1.3
%% by Michael Shell for IEEE CS journal papers
%% http://www.michaelshell.org/
%%
%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall JOSER or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%%*************************************************************************

% Fixes by Dave
\setlength{\paperheight}{11in}
\PassOptionsToPackage{pdfpagelabels=false}{hyperref} 



\documentclass[10pt,journal,compsoc]{joser1}

% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
   \usepackage[pdftex]{graphicx}
\else
   \usepackage[dvips]{graphicx}
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% will be inserted by the editor %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\journalnumber{1}                       %will be inserted by the editor
\journalvolume{1}                       %will be inserted by the editor
\journalmonth{September}                %will be inserted by the editor
\journalyear{2013}                      %will be inserted by the editor
\articlefirstpage{1}                  %will be inserted by the editor
\articlelastpage{10}                   %will be inserted by the editor
\setcounter{page}{1}                  %will be inserted by the editor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\copyrightauthor{D. Coleman, N. Correll}
\headoddname{F. A. AUTHOR et al./ Preparation of Papers for {\sl Journal of Software Engineering for Robotics}}%

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
% paper title
\title{Reducing the Barrier to Entry of \\\vskip 0.3\baselineskip Complex Robotic Software}

\author{
David COLEMAN$^{1}$
\qquad
Nikolaus CORRELL$^{1}$
%\qquad
%Third AUTHOR$^2$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% will be inserted by the editor %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thanks{{\bf Regular paper} -- Manuscript received April 19, 2009;
revised July 11, 2009.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem This work was
supported by xxxxxxxx (No.xxxxxxxx) (sponsor and financial support
acknowledgment goes here).\protect\\

\IEEEcompsocthanksitem Authors retain copyright to their papers
and grant JOSER unlimited rights to publish the paper
electronically and in hard copy. Use
of the article is permitted as long as the author(s) and the journal are properly
acknowledged.}

} % end author

\address{
$^1$ Department of Computer Science, University of Colorado at Boulder,
430 UCB, Boulder, Colorado 80309-0430\\
%$^2$ Department of Computing and Electronic Systems, University of
%Essex Colchester CO43SQ, UK 
}


% The paper headers
\markboth

\IEEEcompsoctitleabstractindextext{%
\begin{abstract}
Developing robot-agnostic software frameworks involves synthesizing many disparate fields of robotic theory and software engineering while at the same time accounting for a large variability in hardware designs and control paradigms. As the capabilities and power of robotic software frameworks increases, the setup difficulty and learning curve to new users also increases. If the entry barriers for configuring and using the software on robots is too high, even the most powerful of frameworks are useless. A growing need exists in robotic software engineering to aid users in getting started with, and customizing, the provided components as necessary for particular robotic applications. In this paper a case study is presented for some of the best practices found for lowering the barrier of entry of the MoveIt motion planning framework that allows users to 1) quickly get basic motion planning functionality with very little initial setup, 2) automate the configuration and optimization of the framework where possible, and 3) easily customize components of the framework. A graphical interface that assists the user in configuring MoveIt is the cornerstone of our approach, together with a standardized robot model for input, automatically generated configuration files and launch files, and a plugin-based architecture for extensibility. These best practices are summarized into a set of \textit{barrier to entry design principles} applicable to other robot software. The approaches for lowering the entry barrier are evaluated by usage statistics, a user survey, and compared against our design objectives for their effectiveness to users.

\end{abstract}

\begin{IEEEkeywords}
Robotic Software Frameworks, Motion Planning, Barrier to Entry, Setup, Usability, MoveIt
\end{IEEEkeywords}}

% make the title area
\maketitle


% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Introduction}
% The very first letter is a 2 line initial drop letter followed by the rest of the first word in caps.
\IEEEPARstart{M}{anaging} {the increasing complexity of modern robotic software is a difficult engineering challenge faced by roboticists today. The size of the code bases of common open source robotic software frameworks such as ROS \cite{quigley2009ros}, MoveIt \cite{moveit} and OROCOS \cite{bruyninckx2001open} are swelling \cite{makarenko2007benefits}, and the required breadth of knowledge for understanding the deep stack of software from control drivers to high level planners is become more formidable. As it is beyond the capabilities for any one researcher to have the necessary domain knowledge for every aspect of a robot's tool chain, it is becoming increasingly necessary to assist users in the configuration, customization, and optimization of the various software components of a robotic framework. 

The user interface design principles required in the emerging field of robotics software is similar to other more mature software engineering fields and much can be learned from them. There have been many examples of software, such as computer operating systems, that have historically required many installation and configuration steps. As those software fields matured, the entry to barriers have decreased and become easier for users to accomplish. Still, robotics software in general is unique in 1) the degree to which software interacts with hardware and real world environments, 2) the lack of maturity in the field results in many varying approaches for solving a problem, and 3) the long term desire to increase the autonomy of robotics systems. 

% ======================================================================================================
\subsection{Barriers to Entry}

The term \textit{barriers to entry} is used in the context of robotic software engineering to refer to the time, effort, and knowledge that a new user must invest in the integration of a software component to an arbitrary robot. This can include for example creating a virtual model of the robot's geometry and dynamics, customizing configuration files, choosing the fastest algorithmic approach for the application, and finding the best parameters for various algorithms. 

Powerful robotics software generally requires many varying degrees of customization and optimization for any particular robot to operate properly. Choosing the right parameters for each utilized algorithm and software component typically involves expert human input using domain-specific knowledge. Many new users to a software package, particularly as robotics becomes more mainstream, will not have the breadth of knowledge to customize every aspect of the tool chain. When the knowledge of a new user is insufficient for the requirements of the software, the barriers to entry become insurmountable and the software unusable. One of the emerging requirements of robot agnostic frameworks is implementing mechanisms that will automatically setup and tune the pipeline for arbitrary robots.

Another motivation for lowering the barrier to entry of complex robotics software is the \textit{paradox of the active user}. This paradox explains a common observation in many user studies that \textit{users never read manuals} but start attempting to use the software immediately \cite{carroll1987interfacing}. A user's desire to quickly accomplish a task results in them skipping reading any provided documentation or gaining deeper understanding of the system and instead diving right into completing their task. The \textit{paradox} is that the user would actually save time in the long run if they learned more about the system before attempting to use it, but from these studies it was that shown that in reality people do not tend to invest time upfront into learning a new system.

Even experts in the area of the associated robotics software will become frustrated with robotics software if all initial attempts to setup and configure the framework fails and no progress is made. Researchers and engineers today typically do not have the time or ability to completely understand the entirety of robotics software before they start using it. It is very important for the initial experience with a piece of software be positive for the continued use of the software by the user.

% ======================================================================================================
\subsection{Benefits of Larger User Base}

The need to lower the barrier of entry is beneficial to the software itself in that it enables more users to utilize the framework. If the software framework is being sold for profit, the benefits of larger user base is obvious. If instead the software is a free open-source project, as most successful robotic frameworks currently are \cite{makarenko2007benefits}, lowering the barrier to entry is very beneficial in that it creates the \textit{critical mass of skilled contributors} that has been shown to make open source projects successful \cite{bruyninckx2001open}. As the number of users increases, the speed in which bugs are identified and fixed increases \cite{schmidt1999software}. It is also typically hoped that development contributions to the code base increases, though this correlation is not as strong \cite{schmidt1999software}. Additionally, one of the key strengths of a larger community for an open source project is increased participation of users assisting with quality assurance, documentation, and support \cite{schmidt2001leveraging}.

Another benefit of lowering the barrier of entry is it allows the robotics software to additionally become an educational tool for robotics. Not only is the software accessible for academic research and industrial applications, but undergraduate and even primary school students can use it learn some of the higher level concepts of robotic applications as has been demonstrated in \cite{correll2013one, moll2011teaching, ayanian2010development}. This should not be the main focus of most robotics software, but a nice side effect.

% ======================================================================================================
\subsection{Target Users}

The target \textit{users} as used in this paper are engineers, scientists, students, and hobbyists with a general aptitude for software and robotics but who are not necessarily experts in either of those fields. The hope remains that human-robotic interaction for the general population in the future will be based on more natural methods, and that software configuration and GUIs are only necessary for the robot developers themselves.

% ======================================================================================================
\subsection{Easy To Use Software Is Hard}

The software engineering challenges faced in making robot-agnostic code are hard - many shortcuts typical for one single-design must be avoided, such as hard coding in domain-specific values and using heuristics applicable to only one hardware configuration. Accounting for all the edge cases of a robot's design requires many extra levels of abstraction. On top of these challenges, packaging up this powerful software into an easy to use experience for end users requires creating many tools that automate the configuration of the software.

% ======================================================================================================
\subsection{Related Work}

There has been much written and developed to addressed the software engineering challenges of complex robotic frameworks, but typically the identified design goals have emphasized the need for features such as platform independence, scalability, real-time performance, software reuse, and distributed layouts \cite{realtime_framework, collett2005player, kramer2007development}. In \cite{kramer2007development}'s survey of nine open source robotic development environments, a collection of metrics were used which included documentation and graphical user interfaces (GUI), but no mention was made of setup time, barrier to entry, or automated configuration. 

The importance of an open source robotics framework having a large number of researchers and engineers motivated to contribute code and documentation is emphasized in the the OROCOS framework \cite{bruyninckx2001open}, which we emphatically agree with but take a step further by creating even better tools to encourage higher user adoption.
  
Human-robot interaction (HRI) has also been a popular area of research, but HRI's focus has been on the runtime behavior of robots and not on the difficulties of human users applying software frameworks to robot hardware \cite{hci_metrics, yancotaxonomy, goodrichseven}. In \cite{rescueRobots}, an effective user interface is presented for teleoperation of rescue robots, but no thought is given to making it robot agnostic or to configuration. 

From the best of our knowledge, there has been no prior work on the difficulties of setting up and configuring robotics software.

% ======================================================================================================
\subsection{Contribution and Outline}

In this paper we will present best practice principles for lowering the barrier of entry to robotic software using the new MoveIt Motion Planning Framework as our case study. In section \ref{sec::motion_planning} we will motivate the many software components that make motion planning frameworks a good example of the difficulties of complex robotics software and in section \ref{sec::moveit} we will introduce the MoveIt motion planning framework itself. In section \ref{sec::requirements} we explain the design principles used to address the user interface needs of robotics software. We then show how we have taken these principles and implemented them in MoveIt to reduce the entry barriers in section \ref{sec::lowering_barriers}. In section \ref{sec::results} we will present the results of these implementations on the size of the user base and ease of adoption of the MoveIt software framework. We will discuss our experiences and lessons learned in section \ref{sec::discussion} followed by our conclusion in section \ref{sec::conclusion}.

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Motion Planning Frameworks}
\label{sec::motion_planning}

Robotic motion planning is a maturing and central field in robotics \cite{moll2011teaching} that turns a high level task command into a series of discrete motions such that a robot can move within its environment. The typical use case considered in this paper is the problem of controlling a robotic arm from one configuration to another while taking into account various constraints.

The software development of a motion planning framework is challenging and involves combining many disparate fields of robotics and software engineering \cite{perez2010roadmap}. We refer to the software as a \textit{framework} in this context because it abstracts the various components of motion planning into generic interfaces as discussed later.

One of the most important features of a framework for motion planning is providing the structures and classes to share common data between the different components. These basic data structures include a model of the robot, a method for maintaining a representation of the state of the robot during planning and execution, and a method for maintaining the environment as perceived by the robot's sensors (the ''planning scene'').

In addition to the common data structures, a motion planning framework requires many different interacting software components, henceforth referred to as the \textit{planning components}. The planning component that actually contains performs motion planning includes one or more algorithms suited for solving the expected problems a robot will encounter. The field of motion planning is large and no one-size fits all solution exists yet, so a framework that is robot agnostic should likely include an assortment of algorithms and algorithm variants.

TODO: create figure of the flow of data and functionality for motion planning? 

Other planning components include a collision checking module that detects the potential intersection of geometric primitives and meshes in the planning scene and robot model. A forward kinematics solver is required to propagate the robot's geometry based on its joint positions, and an inverse kinematics solver is required when planning in the Cartesian space of the end effector. Other potential constraints, such as joint/velocity/torque limits, and stability requirements, require additional components.

Secondary components must also be integrated into a powerful motion planning framework. Depending on what configuration space a problem was solved in, a generated motion planning solution of position way points must be parameterized into a time-variant trajectory to be executed. A controller manager must decide the proper low level controllers for the necessary joints for each trajectory. A perception interface updates the planning scene with recognized objects from a perception pipeline as well as optional raw sensor data.

Higher level applications are built on top of these motion planning components to coordinate more complex tasks, such as pick and place routines. Other optional components of a motion planning framework can include benchmarking tools, introspection and debug tools, as well as the user-facing GUI.

There already exists a number of motion planning frameworks available today, both open and closed source. A quick survey of these software projects... TODO survey motion planning frameworks

\begin{itemize}
    \item ROS Arm Navigation
    \item OpenRave - Open Robotics Automation Virtual Environment
    \item OOPSMP - An Object-Oriented Programming System for Motion Planning
    \item MPK - Motion Planning Kit
    \item Motion Strategy Library
    \item Custom software
\end{itemize}

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{MoveIt Motion Planning Framework}
\label{sec::moveit}

MoveIt is the primary motion planning framework in ROS and has been successfully integrated with many robots including the PR2 \cite{wyrobek2008towards}, Robotnaut \cite{ambrose2000robonaut}, and Atlas. It is a popular open source project that aims to become the open standard for motion planning research and applications. MoveIt is written entirely in C++ but also includes Python bindings for higher level scripting. It follows the principle of software reuse as advocated for robotics in \cite{makarenko2007benefits} of not tying itself exclusively to one robotic framework - in our case ROS - by creating a formal separation between core functionality and robotic framework-dependent aspects. 

By default the MoveIt Motion Planning Framework is built on ROS and integrates the Open Motion Planning Library (OMPL) \cite{sucan2012the-open-motion-planning-library} for planning, the Fast Collision Library (FCL) \cite{fcl} for collision checking, and the OROCOS Kinematics and Dynamics Library (KDL) \cite{kdl} for forward and inverse kinematics. The ability to change these default planning components in discussed in section \ref{subsec:extensiblity}.

MoveIt is fast and can generate complete pick and place plans for a typical robotic arm in TODO: BENCHMARK TIME in preliminary experiments on an 64 bit Ubuntu 12.04 PC with a 3.6Ghz Intal Core i7 processor and 16 GB ram.

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Entry Barrier Design Principles}
\label{sec::requirements}

In designing the configuration process required to enable MoveIt to work with many different types of robots, with almost any combination of planning components, several contending design principles for lowering the barrier of entry emerged. These requirements were drawn partially from standard HCI principles \cite{galitz2007essential}, from work on MoveIt's predecessor - the \textit{arm\_navigation} project, and from an iterative design process where feedback was solicited from the target users. We believe these \textit{entry barrier design principles} transcend motion planning and can be applied to most robotic software:

{\bf Immediate}: The amount of time required to accomplish the most primitive task expected from the robotic software component should be minimized. This is similar to the time-honored ''Hello World'' demo frequently used by programming languages and typical Quick Start guides in documentation. Immediacy is essential for the \textit{paradox of the active user} as it provides cursory feedback to the user that the software works and is worth investing further time.

{\bf Transparent}: The configuration steps being performed automatically for the user, and the underlying mechanisms utilized in the software components, should be as visible as possible. Transparency is important so that the user can later understand what parameters are specific to their robot and know how to customize the aspects they desire. Hide too much of the setup process and the user will be hindered in the future.

{\bf Intuitive}: The need to read accompanied documentation, and the amount of required documentation, should be minimized. A well designed user interface, be it graphical or command line, should be as intuitive as possible by following standard design patterns and providing interface context clues. An ideal GUI for configuration would not require any documentation.

{\bf Reconfigurable}: The automatically generated parameters and default values for the initial setup of a robot should be easy to modify at a later time by the user. Typically these parameters and values are chosen to work for the largest number of robots possible, but are not optimal for any particular robot. Providing easy methods to reconfigure the initial setup is very important. 

{\bf Extensible}: The ability of the user to customize as many components and behaviors as possible within the reasonable scope of the software. Providing the means to extend the software with custom solutions for a particular application will make the software far more powerful and re-usable for varying use-cases. A typical solution for this is providing a plugin interface.

{\bf Documented}: The amount of reference material explaining how to use the software should be maximized for as many aspects and user levels as possible. Even the most intuitive software requires documentation for various aspects of the operation or modification of the software itself. Different types of documentation are needed for different users - for example developers and end users - though in robotics this is frequently the same. Documentation is arguably the most important factor in reducing the barrier to entry of new software. TODO cite documentation importance

Many of these principles have opposing objectives that require a trade off or balance be found between them. For example, the desire for transparency in the underlying mechanisms often leads to slower setup times (immediacy) and more complicated configuration steps (unintuitive). The need for extensibility of various components in the software often results in far more complicated software design as more abstraction is required, resulting in a less intuitive code base and difficult documentation. Nevertheless, compromises can be made between these principles that result in a superior user experience as will be demonstrated in the next section.

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Methods to Lower The Entry Barrier}
\label{sec::lowering_barriers}

One of the unique features of MoveIt is the ratio of its power and features to the required setup time. A beginner to motion planning can take a model of their robot and with very little effort execute motion plans in a virtual environment. With a few additional steps of setting up the correct hardware interfaces, one can then execute the motion plans on actual robotic hardware.

The \textit{entry barrier design principles} discussed above were applied to the MoveIt motion planning framework to address the challenges faced for new users to this complex software framework. Developing these solutions required difficult software challenges be overcome as discussed in the following.

% ======================================================================================================
\subsection{Basic Motion Planning Out of the Box}

To address the entry barrier design principle of \textit{immediacy}, a streamlined ''Quick Start'' for MoveIt was created that consists of a series of fairly trivial steps, relative to our target users. The most challenging of these steps - creating a \textit{robot model} - is not directly related to the configuration of MoveIt, but rather is a prerequisite of using the software framework. Nevertheless, we will discuss this important prerequisite before preceding to the more directly-related configuration steps. 

{\bf Robot Model Format}: The robot model is the data structures and accompanying file format used to describe the three-dimensional geometric representation of the robot, its kinematics, as well as other properties relevant to robotics. These other properties can include the geometric visualization meshes, courser-grained collision geometry of the robot used for fast collision checking, joint limits, sensors, and dynamic properties such as mass, moments of inertia, and velocity limits. In our application, as well as most state of the art motion planning frameworks, we will restrict our definition of modeled robots to arbitrarily articulated rigid bodies.

Extensible robotics software requires using a standardized format that can express the intricacies of varying hardware configurations. An additional design requirement for this standardized format is that it is \textit{intuitive} for users to setup. This was accomplished for MoveIt by utilizing the human-readable XML schema provided by ROS for robot models - the Universal Robotic Description Format (URDF) \cite{urdf}. This data structure format can accept URDF-formatted files, as well as the industry standard Collada \cite{collada} format.

To create the URDF or Collada model for a robot, computer aided design (CAD) software is used to create the 3D geometries of the robot hardware. The generated individual geometric models, often referred to as \textit{links} in robotics, must then be combined into a connected model using \textit{joints}. If the SolidWorks CAD software is used, a converted exists that can automatically converting it to the URDF format. Otherwise, the URDF model must be made by hand, a difficult step of using MoveIt and an area that is in need of future improvement.

{\bf MoveIt Setup Assistant}: The main facility that provides out of the box support for beginners is the MoveIt Setup Assistant (SA). The SA is a GUI that steps new users though the initial configuration requirements of using a custom robot with the motion planning framework (Figure \ref{fig:setupassistant}). It accomplishes the task for the user of automatically generating all the many configuration files necessary for the initial operation of MoveIt. These configurations include a self-collision matrix, planning group definitions, robot poses, end effector semantics, virtual joints list, and passive joints list. To increase the immediacy of results and transparency of the configuration, a three dimensional model of the robot as its being configured is displayed on the right side of the Setup Assistant GUI and various links on the robot are highlighted during configuration to visually confirm the actions of the user, as shown in Figure \ref{fig:setupassistant}.

TODO: talk more about how the user interacts with the GUI

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/setup_assistant}
\caption{Screenshot of MoveIt Setup Assistant with the Robonaut loaded TODO: better picture}
\label{fig:setupassistant}
\end{figure}

Using a properly formatted robot model file with the SA, MoveIt can automatically accomplish many of the required tasks in a motion planning framework. If one desired, the steps within the SA could almost entirely be automated themselves, but they have been kept manual so 1) increase transparency and 2) provide extensibility for edge cases and unusual customizations.

{\bf MoveIt Rviz Motion Planning Plugin}: The details of the automated configuration is left for the next section, but after the steps in the SA are completed a demo script that will automatically startup a visualization tool (rviz) with the new robot loaded and ready to run motion planning algorithms in a non-physics based simulation. A typical demo task would be using the computer mouse to visually drag 3D interactive arrows situated on the robot's end effector from a start position to a goal position around some virtual obstacle. The demo can then quickly plan the arm in a collision free path around the obstacle and visualize the results within rviz. 

This user interaction is accomplished with the MoveIt Rviz Motion Planning Plugin (RMPP), an additional GUI that allows beginning users to learn and experiment with a large subset of the functionality provided by MoveIt (Figure \ref{fig:motionrvizplugin}). While the long term goals of robotics is to provide more autonomous solutions to motion planning and human-robot interactions \cite{yancotaxonomy}, the RMPP fulfills the immediate needs of direct operation for testing and debugging the framework's capabilities easily. This interface is a vital component of MoveIt's strategy to provide immediate results for motion planning with a robot that does not require any custom coding. Once the user is comfortable with the basic feature set and functionality of MoveIt, extensibility is provided via varying levels of code APIs for more direct, non-GUI, access to the robot's abilities.

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/rviz_plugin}
\caption{Screenshot of MoveIt Rviz Motion Planning Plugin with the Robonaut planning between two configurations TODO: better picture}
\label{fig:motionrvizplugin}
\end{figure}

The RMPP provides a large number of features and visual tools for motion planning. Using Rviz and RMPP, visualizations are provided of:
\begin{itemize}
    \item Start and goal configurations of the robot for planning
    \item Current robot hardware configuration
    \item Animated planned path before executing
    \item Detected collisions
    \item Sensor data and recognized objects
    \item Pick and place data such as grasp positions
    \item Attached bodies such as manipulated objects
    \item Planning Metrics
\end{itemize}

Additionally, the RMPP contains many other non-visualization tools such as:
\begin{itemize}
    \item Connecting to a database of planning scenes
    \item Adjusting IK settings
    \item Changing the utilized planning algorithm
    \item Adjusting the workspace size
    \item Adjusting goal tolerance and planning time
    \item Tweaking manipulation plans
    \item Loading and moving collision objects
    \item Exporting/Importing scenes and states
    \item Viewing the status of MoveIt
\end{itemize}

{\bf Hardware Configuration and Execution}: Once the user is comfortable with the basic tools and features provided by MoveIt, the next step is to configure their robot's actual hardware actuators and control interfaces to accept trajectory commands from MoveIt. This step is not as easy and requires some custom coding to account for the specifics of the robot hardware - the communication bus, real-time requirements, and control theory implementations. At the abstract level, all MoveIt requires is that the robot hardware accepts a standard ROS trajectory message containing a discretized set of time-variant waypoints including desired positions, velocities, and accelerations.  

% ======================================================================================================
\subsection{Automatic configuration and optimization}

The size and complexity of a feature-rich motion planning framework like MoveIt requires many parameters and configurations of the software be automatically setup and tuned. MoveIt accomplishes this in the 1) setup phase of a new robot, using the Setup Assistant, 2) during the runtime of the application, and 3) using benchmarking and parameter sweeping.

{\bf Self Collision Matrix}: The first step of the SA is the generation of a self-collision matrix for the robot that is used in all future planning to speed up collision checking. This collision matrix encodes pairs of links on a robot that never need to be checked for self-collision due to the kinematic infeasibility of there actually being a collision. Reasons for disabled collision checking between two links includes:
 
\begin{itemize}
    \item Links that can never intersect due to kinematics
    \item Adjacent links that are connected and so are by design in collision
    \item Links that are always in collision for any other reason including inaccuracies in the robot model and precision errors
\end{itemize}

This self-collision matrix is generated by running the robot through tens of thousands of random joint configurations and recording statistics of each link pair's collision frequency. The algorithm then creates a list of link pairs that have been determined to never need to be collision checked. This reduces future motion planning runtimes because it reduces the amount of required collision checks for every motion planning problem. TODO discuss completeness characteristics?

{\bf Configuration Files}: The other six steps of the SA all provide graphical front ends for the data required to populate the Semantic Robotic Description Format (SRDF) and other configuration files used by MoveIt. The SRDF provides semantic meta data of the robot model useful to motion planning but not relevant to the URDF because it does not describe physical properties of the robot. The SRDF information includes which set of joints constitutes an arm and which set of links is considered part of the end effector. It is one of the main components that allows MoveIt to be robot agnostic and to avoid dependencies on specific robots \cite{moveit}. Requiring the user to configure all the semantic information by hand in a text editor would be tedious and more difficult than using a GUI. The GUI populates the available options for each input field in list boxes and guides the user through filling in the necessary fields with buttons and graphical feedback.

The last step of the SA is to generate all launch scripts and configuration files. This step outputs to file the information collected from the user during the step-by-step user interface, as well as generates a series of default configuration and launch files that are automatically customized for the particular robot using the URDF and SRDF information. These defaults include velocity and acceleration limits for each joint, kinematic solvers for each planning group, available planning algorithms, and projection evaluators for planning. Default planning adapters are setup for pre- and post-processing of motion plans. Default benchmarking setups, controller and sensor manager scripts, and empty object databases are all generated using launch files, which essentially allow one to start different sets of MoveIt functionality that are already put together. These defaults can later easily be modified by simply editing the text-based configuration files.

{\bf Automatic Runtime Tuning}: MoveIt is designed to simplify solving planning problems by reducing the number of hard-coded parameters and so called ''magic numbers''. During runtime, MoveIt is able to automatically choose good values for certain parameters to reduce the amount of expert domain knowledge required and make MoveIt extensible to a larger set of problems. 

An example of automatic runtime tuning is the resolution in which collision checking is performed - it is defined as a fraction of the space extent. The space extent depends on the joint limits, the types of joints, and the planning groups being used. Another example is using projections to Euclidean spaces to estimate coverage during planning. By default in MoveIt, the projects are computed randomly and their bounds are found by sampling.

{\bf Benchmarking}: The ability to configure and switch out different planning components is a powerful feature of MoveIt, but its usefulness is limited without the ability to quantify the results of different approaches. Optimization criteria such as path length, planning time, smoothness, distance to nearest obstacle, and energy minimization need benchmarking tools to enable users and developers to find the best set of parameters and planning components for any given robotic application.

MoveIt lowers the barrier to entry to benchmarking by providing a command line-based infrastructure and benchmarking configuration files that allows each benchmark to easily be setup for comparison against other algorithms and parameters \cite{cohen2012generic}. An additional GUI is currently in development that makes benchmarking even easier and reduces the learning curve to this feature set of MoveIt.

Choosing the best combination of planning components and parameters for any particular robot and problem is a daunting task even for experts because of the number of choices that must be made\cite{cohen2012generic}. A common method to optimize an algorithms performance is to perform single and multivariable parameter sweeps during benchmarking. MoveIt provides an interface for this in its benchmarking infrastructure by allowing a upper, lower, and increment search values to be provided by the user. Results can be output into generic formats for use in different plotting tools for analysis of which combination of parameters performed best.

% ======================================================================================================
\subsection{Easily customize components of the framework}
\label{subsec:extensiblity}

Out of the box, MoveIt lowers the barrier to entry by not requiring users to provide their own implementation of any of the components in the motion planning framework. The default planning components are the aforementioned OMPL, FCL, and KDL. However, these default components are limiting to more advanced users who have their own application or research-specific needs to fulfill. 

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/moveit_plugins}
\caption{Available planning component plugins for easily extending the functionality of MoveIt.}
\label{fig:moveit_plugins}
\end{figure}

{\bf Plugins}: MoveIt is extensible by allowing its various planning components to be customized through a lightweight plugin interface. This is accomplished using C++ shared objects that are loaded at run time, reducing dependency complexities. This plugin-centric framework, as seen in Figure \ref{fig:moveit_plugins}, provides interfaces for forward and inverse kinematics, collision detection, planning, planning request adapters, controllers, octomap perception, and higher level capabilities. Almost all aspects of MoveIt's functionality can be extended using plugins.

A particular strong point of MoveIt's feature set is its kinematics plugins it can automatically generate using the input URDF. The default KDL plugin uses numerical techniques to convert from a Cartesian space to joint configuration space. A must faster solution can be achieved by utilizing OpenRave's IKFast \cite{ikfast} plugin that analytically solves the inverse kinematics problem. A combination of MoveIt scripts and the IKFast Robot Kinematics Compiler can automatically generate the C++ code and plugin needed to increase the speed of motion planning solutions by up to 3 orders of magnitude \cite{ikfast}.

Essentially, MoveIt provides a set of data sharing and synchronization tools, sharing between all planning components the robot's model and state. The extensibility of MoveIt's framework is greatly enhanced by not forcing users to use any particular algorithmic approach. 

{\bf High Level Interfaces}: High level task scripting is easily accomplished in MoveIt with both a C++ and python interface that abstracts away most of the underlying mechanisms in MoveIt. User who do not wish to bother with how the various low level planning components are operating can instead focus on the high level application tasks such as picking up and object and manipulating it. Python in particular is a very easy scripting language that enables powerful motion planning tasks be accomplished with very little effort.

% ======================================================================================================
\subsection{Other Methods}

Though extremely common place in open source software projects \cite{bruyninckx2001open}, it should be mentioned for completeness that MoveIt addressed the \textit{entry barrier design principle} of \textit{documentation} by providing extensive wiki pages, a mailing list for questions, and a issue tracker for bug reports and feature requests.

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Results}
\label{sec::results}

The success of MoveIt's efforts to lower its barrier of entry to new users through the application of the barrier to entry principles is quantified in the following. Its adoption rate, community activity, contributors, and results from a user survey are used as indicators of its progress.

\subsection{Statistics}
\label{sec::statistics}

MoveIt was officially alpha released on May 6th, 2013. As of this writing, 170 days since its release, there have been TODO XX debian downloads from its supported Ubuntu operating system.

There are currently 165 users on the MoveIt mailing list as shown over time in Figure \ref{fig:membership_plot}. The posting activity of the mailing list over time in shown in Figure \ref{fig:mailing_list}.

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/membership_plot}
\caption{Membership of MoveIt mailing list over time.}
\label{fig:membership_plot}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/mailing_list}
\caption{Total posts on the MoveIt mailing list. TODO: add axis labels}
\label{fig:mailing_list}
\end{figure}

There have been a total of 48 contributors to the code base since its initial development began in 2011. The number of contributors over time is shown in Figure \ref{fig:contributors}. According to statistics gathered by Ohloh, MoveIt is ''one the largest open-source teams in the world and is in the top 2\% of all project teams on Ohloh'' \cite{ohloh}.

\begin{figure}[!t]
\centering
\includegraphics[width=3.4in]{images/contributors}
\caption{Total code contributors to MoveIt across all repositories. TODO cleanup diagram, add titles and axis labels}
\label{fig:contributors}
\end{figure}


\subsection{Survey}
\label{sec::survey}

A survey on MoveIt user's experience with the software were administered within

details

details

details

details

details

details

details

plot 

plot 

plot 

plot 

plot 

plot 

plot 

plot 

plot 

plot 

plot 

plot 

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Discussion}
\label{sec::discussion}

\subsection{MoveIt Setup}
\label{sec::moveit_discussion}

We believe the setup process for MoveIt is easier than most open source robotics software available today, and as a result it has in a short amount of time become popular in the robotics community as a powerful motion planning framework that is extensible to most user's needs. The adoption rate of MoveIt since its official release less than half a year ago has been very positive and the number of contributors has been better than expected. Ohloh's ranking of MoveIt as one of the largest open source teams in the world confirms our belief that by making complex software more accessible, more developers will be able to report and fix issues. 

It is important to emphasize the effect of a quick \textit{Getting Started} demo on a new user unaccustomed to MoveIt or motion planning in general. The positive reinforcement of a quick initial success encourages the novice to continue to use the software and enables them to begin going deeper into the functionality and code base. If the entry barrier is too high, that is to say if it is too complex and error-prone, a new user will likely give up and turn to other frameworks or custom solutions. Attempting to blindly fix software that a new user has not had any success with is a very difficult task.

Still, the setup and configuration process has room for improvement as indicated by the survey's TODO. Creating the robot model itself is a difficult task that typically requires a lot of trial and error in configuring the links and joints properly. This process could be improved by a better GUI for making arbitrary robot models. 

Setting up the hardware controllers can also be a difficult task for non-experts and the MoveIt setup process does not document and provide example code as well as it could. It is likely this step will continue to require some custom coding to account for arbitrary hardware interfaces and communication methods, but based on the feedback we have received from actual users, this is certainly an area of improvement. 

Finally, although MoveIt is very extensible with its plugin-based architecture, modifying the actual code base of MoveIt can be intimidating due to its large size. Currently, MoveIt contains 173,376 lines of code across all its various packages. Due to the need for computational speed and power, the layout of the code can sometimes seem complicated and too abstracted. Finally, over half of the code base has been created by a single developer, so readability has not been the highest objective. 

\subsection{Robotic Software}
\label{sec::robotic_discussion}

The techniques utilized in the development of MoveIt can easily be applied to robotics software in general. Almost all robotics software requires customizations specific to a particular hardware and kinematic configuration. Reducing the difficulty of performing these customizations should be the goal of robotic software engineers who desire to create useful tools for a large audience. 

For example, in perception applications such as visual servoing, frame transforms must be specified of the location of the camera to the rest of the robot's geometry. This is often a difficult and tedious task CITE. Automating the calibration of these transforms lowers the barrier of entry to new users to robotic vision software and makes the vision software useful to more users.

Creating a GUI such as the Setup Assistant is a time consuming process that many robotics developers avoid in favor of manual or command-line based configuration. As discussed in the introduction, we believe that the trade off in the time invested is worthwhile for the higher adoption rates and creation of a larger community willing to contribute to the software's development. It is understandable that when robotics research is the priority, spending time on tangential aspects of the project such as GUIs and configuration tools can be less important to the researcher. Still, we would like to encourage researchers and developers alike to, when possible, spend the extra time making their work reusable by taking into consideration the barriers to entry that other users might encounter. Too often, software is touted as ''open source'' when its usefulness is in actuality severely limited by the difficulties encountered in applying it to other projects by other users. By sharing accessible open source robotics software, the progress of robotic technology is accelerated and the robotics community on the whole benefits.

TODO: more about how these results can be generalized and standardized

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section{Conclusion}
\label{sec::conclusion}

Beyond the usual considerations in building successful robotics software, an open source project that desires to maintain an active user base needs to take into account the barrier of entry to new users. As the algorithms become more complicated and the number of planning components and size of the code base increases, configuring an arbitrary robot to utilize robotic software becomes a daunting task requiring domain-specific expertise in a very large breadth of theory and implementation. To account for this, quick and easy initial configuration, with partially automated optimization, and easily extensible components for future customization are becoming a greater necessity in motion planning and robotic software engineering in general. 

% ======================================================================================================
% ======================================================================================================
% Section
% ======================================================================================================
% ======================================================================================================
\section*{Acknowledgments}
The authors would like to thank...

TODO: references lack details such as journal title etc. 

% references section
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,moveit_setup_bibliography}


% biography section
\begin{IEEEbiography}[{coleman}]{Dave Coleman}, M.S., 2013, is a Ph.D. candidate in Computer Science at the University of Colorado. He obtained his B.S. in Mechanical Engineering at the Georgia Tech and Masters in C.S. at CU Boulder. David's research interests include robotic manipulation, motion planning, and controls. He is one of the main developers of MoveIt, creating the MoveIt Setup Assistant while interning at Willow Garage continuing development at the Open Source Robotics Foundation and with his regular research.
\end{IEEEbiography}

\begin{IEEEbiography}[{nikolauscorrell}]{Nikolaus Correll}, M.S., 2003, Ph.D., 2007, is an Assistant Professor in Computer Science at the University of Colorado. He obtained his Master's degree in Electrical Engineering from ETH Z\"urich, a Ph.D. in Computer Science from EPFL and worked as a post-doc at MIT CSAIL. Nikolaus's research interests are multi-robot and swarming systems. He teaches ``Introduction to Robotics'' and ``Advanced Robotics'' to third- and fourth-year students.
\end{IEEEbiography}


% insert where needed to balance the two columns on the last page with
% biographies

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}

% that's all folks
\end{document}
